\subsection{Grover's Algorithm and QRAM}

Quantum Random Access Memory (QRAM) enables a database to be queried in superposition by routing all address qubits at once through a shallow, reversible network.  This reduces each oracle call in Grover's search to logarithmic depth, rather than linear depth of naive look-up, so that overall runtime remains dominated by algorithm \(\mathcal{O}(\sqrt{N})\) iterations.  In practice, one forwards the address register through QRAM to load the data, applies a phase flip on the marked element, and then uncomputes the route to erase entanglement, preserving coherence throughout amplitude amplification.  

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{images/Grover's_algorithm.png}
    \caption{Schematic of Grover's algorithm with an oracle.}
    \label{fig:grover}
\end{figure}

To implement the oracle in Grover's algorithm using QRAM, we perform the following steps:

\begin{enumerate}
  \item \textbf{Load QRAM:} Route the address register through the QRAM network to retrieve the data value into an auxiliary / data register.
  \item \textbf{Apply Phase Flip:} Conditioned on the data register that matches the target value, flip the phase of the joint state.
  \item \textbf{Unload QRAM:} Reverse the routing path to uncompute the QRAM switches, disentangling the address bus while preserving the phase marking on the target.
\end{enumerate}

Next, we will use the theoretical framework described above to implement both bucket-brigade and flip-flop QRAM architectures within the context of Grover's algorithm using the Qiskit library.

\subsection{Bucket-Brigade QRAM in Grover Algorithm}
\subsubsection{Environment Setup and Package Imports}
% Import Qiskit and other required Python packages

\begin{lstlisting}[language=python]
from qiskit.circuit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.visualization import plot_histogram
from qiskit.compiler import transpile
from qiskit_aer import AerSimulator
import numpy as np, random, math
import pkg_resources
\end{lstlisting}

The following libraries are used to construct, execute, and analyze a Grover's algorithm simulation in Qiskit:

\begin{itemize}
  \item \texttt{QuantumCircuit, QuantumRegister, ClassicalRegister}  
    — Core Qiskit classes for building the quantum circuit:  
    \texttt{QuantumRegister} holds the address and data qubits,  
    \texttt{ClassicalRegister} stores measurement outcomes,  
    and \texttt{QuantumCircuit} ties them together into a runnable circuit.

  \item \texttt{plot\_histogram}  
    — Visualization utility to display measurement statistics (probability distribution over outputs) and verify that the marked state is amplified.

  \item \texttt{transpile}  
    — Optimizes and maps the abstract circuit onto the target simulator's basis gates, improving depth and performance.

  \item \texttt{AerSimulator}  
    — Qiskit‐Aer backend for high-performance statevector or shot-based simulation, allowing us to run the Grover circuit with or without noise.
\end{itemize}

\subsubsection{Parameters and Random Target}
% Define problem size \(N\), target element, and other simulation parameters

\begin{lstlisting}{language=python}
n = 3 
N = 2**n
target_index = random.randrange(N)
memory = [0]*N
memory[target_index] = 1
target_str = format(target_index, f'0{n}b')
\end{lstlisting}

This code randomly selects a target index from the \(2^n\) possible states of an \(n\)-qubit system and marks it in the classical memory array.

\subsubsection{Quantum Register Declaration}
% Create address register, data register, and ancilla registers

\begin{lstlisting}{language=python}
addr   = QuantumRegister(n, 'addr')    
router = QuantumRegister(N, 'router')  
anc    = QuantumRegister(1, 'anc')     
data   = QuantumRegister(1, 'data')    
cl     = ClassicalRegister(n, 'cl')    
qc = QuantumCircuit(addr, router, anc, data, cl)
\end{lstlisting}

This step allocates and bundles all registers required for the QRAM oracle:
\begin{itemize}
  \item \texttt{addr}: \(n\) qubits holding the address to query.
  \item \texttt{router}: \(2^n\) qubits forming the decoding network.
  \item \texttt{anc}: one ancilla qubit for implementing controlled operations.
  \item \texttt{data}: one qubit to load the memory value for phase marking.
  \item \texttt{cl}: \(n\) classical bits to record the final measured address.
\end{itemize}


\subsubsection{QRAM Oracle Architecture}
% Build the bucket–brigade switch network: load, phase flip, and unload

\begin{lstlisting}{language=python}
# Step 1: Apply Hadamard on address register to create superposition
qc.h(addr)

# Step 2: Build bucket-brigade decoder network
for i in range(N):
    bin_address = format(i, f'0{n}b')
    # Encode address bits into router control lines
    for bit_idx, bit_val in enumerate(bin_address):
        if bit_val == '0':
            qc.x(addr[bit_idx])
    qc.mcx(addr, router[i])       # Multi-controlled X to set router[i]
    # Restore original address bits
    for bit_idx, bit_val in enumerate(bin_address):
        if bit_val == '0':
            qc.x(addr[bit_idx])

# Step 3: Load data into the data qubit using router lines
for i in range(N):
    if memory[i] == 1:
        qc.cx(router[i], data[0])

# Oracle: apply phase flip on the data qubit
qc.z(data[0])

# Step 4: Unload data (reverse of Step 3)
for i in reversed(range(N)):
    if memory[i] == 1:
        qc.cx(router[i], data[0])

# Step 5: Reset router network (reverse of Step 2)
for i in reversed(range(N)):
    bin_address = format(i, f'0{n}b')
    for bit_idx, bit_val in enumerate(bin_address):
        if bit_val == '0':
            qc.x(addr[bit_idx])
    qc.mcx(addr, router[i])
    for bit_idx, bit_val in enumerate(bin_address):
        if bit_val == '0':
            qc.x(addr[bit_idx])
\end{lstlisting}

\begin{itemize}
  \item \textbf{Hadamard on \texttt{addr}} prepares all \(2^n\) addresses in superposition.
  \item \textbf{Decoder network (router)}: for each address \(i\), conditional \(\mathrm{MCX}\) gates route the address path into the corresponding \texttt{router[i]} qubit.
  \item \textbf{Data load}: controlled-\(\mathrm{X}\) gates from active router lines fetch the stored bit into \texttt{data}.
  \item \textbf{Oracle phase flip}: a \(Z\) gate flips the phase of the marked state on \texttt{data}.
  \item \textbf{Data unload}: reverse the loading step to uncompute data mapping.
  \item \textbf{Router reset}: reverse the decoder construction to clear entanglement in the router network.
\end{itemize}

\subsubsection{Diffusion Operator}
% Construct the inversion‐about‐average circuit (diffuser)

\begin{lstlisting}{language=python}
# Diffusion (inversion-about-the-mean) operator on addr register
qc.h(addr)
qc.x(addr)
qc.h(addr[-1])
qc.mcx(addr[:-1], addr[-1], ancilla_qubits=[anc[0]])
qc.h(addr[-1])
qc.x(addr)
qc.h(addr)
\end{lstlisting}

The diffusion operator serves to amplify the amplitude of the marked state after the oracle has applied a phase flip.

\subsubsection{Measurement}
% Execute measurements, collect statistics, and analyze success probability and circuit depth
After the oracle and diffusion steps, we perform a measurement of the address register to read out the result:

\begin{lstlisting}[language=python]
# Collapse the quantum state into classical bits
qc.measure(addr, cl)
\end{lstlisting}

This instruction maps the superposed amplitudes of \texttt{addr} into classical outcomes \texttt{cl}, yielding one of the \(2^n\) basis states with probabilities determined by the amplitude distribution.  

To verify our analytic prediction and collect statistics, we run the circuit multiple times:

\begin{lstlisting}[language=python]
# Number of shots for empirical measurement
small_shots = 10000
sim_small   = AerSimulator()

# Copy the circuit and ensure all qubits are measured
qc_small    = qc.copy()
qc_small.measure_all()

# Execute and retrieve counts
result = sim_small.run(qc_small, shots=small_shots).result()
counts = result.get_counts()
\end{lstlisting}

Finally, we visualize the frequency of each outcome using a histogram.

\begin{lstlisting}[language=python]
plot_histogram(counts)
\end{lstlisting}

The resulting histogram shows a clear peak in the marked state, confirming that the Grover oracle plus diffusion successfully amplifies the probability of the target above the uniform background.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{images/bb_n=3_i=1.png}
    \caption{Measurement of bucket brigade n=3 when only one iteration}
    \label{fig:grover}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{images/bb_n=3_circuit.png}
    \caption{bucket brigade n=3 circuit}
    \label{fig:grover}
\end{figure}

For \(n=3\) qubits, the search space size is
\[
N = 2^3 = 8.
\]
The fundamental angle is
\[
\theta_0 = \arcsin\!\bigl(1/\sqrt{N}\bigr)
= \arcsin\!\bigl(1/\sqrt{8}\bigr)\approx0.3614.
\]
The optimal number of Grover iterations is
\[
k_{\mathrm{opt}}
= \left\lfloor \frac{\pi}{4\,\theta_0} \right\rfloor
= \left\lfloor \frac{\pi}{4 \times 0.3614} \right\rfloor
= 2.
\]
The maximum success probability is
\[
P_{\mathrm{theory}}
= \sin^2\!\bigl((2\,k_{\mathrm{opt}}+1)\,\theta_0\bigr)
= \sin^2(5 \times 0.3614)
\approx 0.9453 \quad (\approx94.5\%).
\]

\noindent Therefore, after the initial Hadamard layer in the address register, one should repeat the following two-step Grover iteration exactly \(k_{\mathrm{opt}}=2\) times:
\begin{enumerate}
  \item \textbf{Quantum Oracle:} (QRAM load → phase flip → QRAM unload)  
  \item \textbf{Diffusion Operator:} inversion about the mean on the address register
\end{enumerate}
This achieves the highest probability of measuring the marked state for \(n=3\).

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{images/bb_n=3_i=2.png}
    \caption{bucket brigade n=3 achieves the highest probability after two iterations}
    \label{fig:grover}
\end{figure}

\newpage 
\subsection{Flip-Flop QRAM in Grover Algorithm}

\subsubsection{Quantum Register Declaration}

\begin{lstlisting}[language=python]
addr = QuantumRegister(n, 'addr')   # address register
data = QuantumRegister(1, 'data')   # data qubit for fetched value
anc  = QuantumRegister(1, 'anc')    # ancilla for conditional phase flip
cl   = ClassicalRegister(n, 'cl')   # classical bits for measurement
qc   = QuantumCircuit(addr, data, anc, cl)
\end{lstlisting}

Unlike the QRAM bucket bridge, which allocates a full \texttt{router} register of size \(2^n\) for its switching network, the flip–flop design embeds the routing logic directly into controlled gates in the \texttt{addr} and \texttt{data} qubits.  This eliminates the need for a large router register, reducing qubit overhead at the expense of a deeper, sequential gate structure.

\subsubsection{QRAM Oracle Architecture}
This implementation uses a flip-flop-style QRAM oracle, without a large router register, by matching each address pattern directly on the data qubit:

\begin{lstlisting}[language=python]
# Step 1: Create superposition on address register
qc.h(addr)

# Step 2: Encode address and load memory into data qubit
thetas = [math.pi if memory[j]==1 else 0 for j in range(N)]
for j, theta in enumerate(thetas):
    for bit in range(n):
        if ((j >> bit) & 1) == 0:
            qc.x(addr[bit])
    qc.mcx(addr, anc[0], ancilla_qubits=[])
    qc.cry(theta, anc[0], data[0])
    qc.mcx(addr, anc[0], ancilla_qubits=[])
    for bit in range(n):
        if ((j >> bit) & 1) == 0:
            qc.x(addr[bit])
            
# Oracle: phase flip on the loaded data qubit
qc.z(data[0])

# Step 3: Unload data by reversing Step 2
for j, theta in reversed(list(enumerate(thetas))):
    for bit in range(n):
        if ((j >> bit) & 1) == 0:
            qc.x(addr[bit])
    qc.mcx(addr, anc[0], ancilla_qubits=[])
    qc.cry(-theta, anc[0], data[0])
    qc.mcx(addr, anc[0], ancilla_qubits=[])
    for bit in range(n):
        if ((j >> bit) & 1) == 0:
            qc.x(addr[bit])
\end{lstlisting}

\begin{itemize}
  \item \textbf{No dedicated router register:} Unlike the bucket-brigade tree (which uses a \(2^n\)-qubit \texttt{router} register to fan out address lines), flip–flop applies multi-controlled gates directly on the \texttt{addr} and \texttt{data} qubits.
  \item \textbf{Sequential control flow:}  
    Each address bit pattern is processed in sequence: encode, fetch, phase flip, and uncompute, resulting in a deeper circuit but lower qubit count.
  \item \textbf{Ancilla reuse:}  
    A single ancilla qubit (\texttt{anc}) is reused for all multi-controlled operations, instead of per-node storage.
\end{itemize}

This design trades off increased circuit depth and gate count for reduced qubit overhead, making it suitable when qubit resources are more constrained than coherence time.  

\subsubsection{Measurement}
After running the oracle and diffuser, we measure the \texttt{addr} register on the computational basis. This collapses the superposition into a single basis state, with probabilities given by the amplified amplitudes.  

Because both the bucket–brigade and flip–flop QRAM implementations perform the same Grover iterations (oracle load phase flip unload diffusion) in the address register, they yield identical measurement statistics. In particular, both architectures achieve the same optimal success probability.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{images/ff_n=3_i=2.png}
    \caption{flip-flop n=3 achieves the highest probability after two iterations}
    \label{fig:grover}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/ff_n=3_circuit.png}
    \caption{flip-flop n=3 circuit}
    \label{fig:grover}
\end{figure}

\newpage 
\subsection{Width and Depth}
Next, we will compare the circuit width and depth of the bucket-brigade and flip-flop QRAM architectures.

\begin{lstlisting}[language=python]
# Measure circuit width and depth using Qiskit built-in methods
print(f"Total qubits: {qc.num_qubits}")
print(f"Circuit depth: {qc.depth()}")
\end{lstlisting}

Here, \verb|qc.num_qubits| returns the total number of qubits (circuit width), and \verb|qc.depth()| computes the maximum number of sequential gate layers (circuit depth).

\begin{figure}[h!]
  \centering
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/bb_width.png}
    \label{fig:bb_width}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/ff_width.png}
    \label{fig:ff_width}
  \end{subfigure}
  \caption{Comparison of circuit width for two QRAM architectures }
  \label{fig:width_comparison}
\end{figure}


\begin{figure}[h!]
  \centering
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/bb_depth.png}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/bb_log_depth.png}
  \end{subfigure}
  \caption{bucket brigade circuits depth vs number of qubits}
\end{figure}
\newpage 
\begin{figure}[h!]
  \centering
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/ff_depth.png}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/ff_log_depth.png}
  \end{subfigure}
  \caption{flip flop circuits depth vs number of qubits}
\end{figure}


\subsubsection{Design Trade-off}

\begin{itemize}
  \item \textbf{Bucket–Brigade QRAM}:  
    Uses a \(2^n\)-qubit router, producing a very wide circuit but allowing parallel routing.  
    The exponential depth and count of the gates grow slower, making it relatively shallow with moderate gate overhead.

  \item \textbf{Flip–Flop QRAM}:  
    Eliminates the large router register, so the width scales only as \(n\).  
    Routing is done sequentially via multi-controlled gates, resulting in exponential depth and gate count grow faster.  
\end{itemize}
